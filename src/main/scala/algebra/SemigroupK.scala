
package architect
package algebra

import algebra.stones.SemigroupKComponent
import annotation.implicitNotFound
// TODO: Add tests
/**
    Higher-kinded alternative to a Semigroup trait, useful for a higher-kinded types such as List or Option.
    
    - Instances are required to satisfy the category laws:

        (associativity) if f : a → b, g : b → c and h : c → d then h <<< (g <<< f) = (h <<< g) <<< f, and

    - And the additional law:

        (associativity) (x <> y) <> z = x <> (y <> z)
*/

// It doesn't inherit from Semicategory, as they have different kinds
@implicitNotFound("A value of type SemigroupK[${F}] cannot be found")
trait SemigroupK[F[_]] extends SemigroupKComponent[F] { self =>

    def construct[A]: Semigroup[F[A]] =
        new Semigroup[F[A]]{

            def combine(a: F[A], b: F[A]): F[A] = self.combine(a, b)
            
        }

    // Composes two higher kinded types F and G to F[G[α]]. For example, List[Option[Int]].
    // The composition operation F[A] just depends on the structure of F, but not the structure of A.
    def compose[G[_]: SemigroupK]: SemigroupK[{type λ[α] = F[G[α]]}#λ] =
        new ComposedSemigroupK {
            val F = self
    }
     
}

object SemigroupK {

    def apply[F[_]](implicit instance: SemigroupK[F]): SemigroupK[F] = instance

    object Ops {

        implicit class toSemigroupKObject[F[_], A](self: F[A])(implicit tc: SemigroupK[F]) extends SemigroupKComponent.Ops[F,A] { 
            override val typeClassInstance = tc
            override val target = self
        }
    }
}

// Helper for the composition operation
private[algebra] trait ComposedSemigroupK[F[_], G[_]] extends SemigroupK[{type λ[α] = F[G[α]]}#λ] {

    def F: SemigroupK[F]

    override def combine[A](x: F[G[A]], y: F[G[A]]): F[G[A]] = F.combine(x, y)
}

/**
    Semigroups have the ability to arbitrarily partition your data and combine it.
    For ex. Being a Semigroup means you can combine adjacent Logs into an aggregate Log in any order you want. 
    You could split up the work of combining Logs across multiple threads and 
    know that it is still 100% safe to combine the individual thread’s results into a final result.

    Carrying on with the idea of Logs, consider a remote logging service that accepts Logs 
    from your various servers and aggregates them down into something you can do reporting on. 
    If we still have a Log type that is a Semigroup, we have a lot of freedom in how we proceed.
    For example, when a Log is generated by one of your servers, it could send it immediately, 
    or combine some number of Logs before sending them.

    https://blog.axosoft.com/monoids-practical-category-theory/
*/